= The Thucydides Reference Manual
John Ferguson Smart
v0.9.229, January 2014

:author: John Ferguson Smart
:data-uri:
:doctype: book
:toc:         
:lang: en
:encoding: iso-8859-1

[[preface-copyright]]
[preface]
== Copyright

Copyright © 2011-2014 John Ferguson Smart.

Online version published by Wakaleo Consulting.

This work is licensed under a Creative Commons
Attribution-Noncommercial-No Derivative Works 3.0 United States
license. For more information about this license, see
http://creativecommons.org/licenses/by-nc-nd/3.0/us/[creativecommons.org/licenses/by-nc-nd/3.0/us/].

Java™ and all Java-based trademarks and logos are trademarks or
registered trademarks of Sun Microsystems, Inc., in the United States
and other countries.

Eclipse™ is a trademark of the Eclipse Foundation, Inc., in the United
States and other countries.

Apache and the Apache feather logo are trademarks of The Apache
Software Foundation.
  
Many of the designations used by manufacturers and sellers to
distinguish their products are claimed as trademarks. Where those
designations appear in this book, and Wakaleo Consulting was
aware of a trademark claim, the designations have been printed in caps
or initial caps.

While every precaution has been taken in the preparation of this book,
the publisher and authors assume no responsibility for errors or
omissions, or for damages resulting from the use of the information
contained herein.

[[introduction]]
== Introducing Thucydides

Thucydides (Thoo-SID-a-dees) is a tool designed to make writing automated acceptance and regression tests easier ( Refer to Pt. 3 ). It provides features that make it easier to organize and structure your acceptance tests, associating them with the user stories or features that they test. As the tests are executed, Thucydides generates illustrated documentation describing how the application is used based on the stories described by the tests. 

Thucydides provides strong support for automated web tests based on Selenium 2 ( http://docs.seleniumhq.org/projects/webdriver/ ), though it can also be used effectively for non-web tests ( ? ).
          
Thucydides was a Greek historian ( http://en.wikipedia.org/wiki/Thucydides ) known for his astute analysis skills who rigorously recorded events that he witnessed and participated in himself. In the same way, the Thucydides framework observes and analyzes your acceptance tests, and records a detailed account of their execution.
                
[[basic-concepts]]

include::basic-concepts.doc[]

== Getting started with Thucydides

include::getting-started.doc[] 

== Writing Acceptance Tests with Thucydides  

include::writing-acceptance-tests.doc[]

== Defining high-level tests

include::high-level-tests.doc[]   
             
== Writing Acceptance Tests with JBehave

include::jbehave.doc[]

== Defining Page Objects   
  
include::page-object.doc[]

== Advanced JIRA Integration

include::jira-integration.doc[]

== Spring Integration

include::spring-integration.doc[]

== Thucydides Report Configuration

include::report-configuration.doc[]

== Running Thucydides tests from the command line

You typically run Thucydides as part of the build process (either locally or on a CI server). In addition to the +webdriver.driver+ option discussed about, you can also pass a number of parameters in as system properties to customize the way the tests are run. The full list is shown here:

  * *properties*: Absolute path of the property file where Thucydides system property defaults are defined. Defaults to +~/thucydides.properties+

	* *webdriver.driver*: What browser do you want your tests to run in: firefox, chrome or iexplorer. Basic support for iPhone and Android drivers is also available.

	* *webdriver.base.url*: The default starting URL for the application, and base URL for relative paths.

  * *webdriver.remote.url*: The URL to be used for remote drivers (including a selenium grid hub)

  * *phantomjs.webdriver.port* What port to run PhantomJS on (used in conjunction with webdriver.remote.url to register with a Selenium hub, e.g. -Dphantomjs.webdriver=5555 -Dwebdriver.remote.url=http://localhost:4444

  * *webdriver.remote.driver*: The driver to be used for remote drivers

	* *webdriver.timeouts.implicitlywait*: How long webdriver waits for elements to appear by default, in milliseconds.        

  * *thucydides.home*: The home directory for Thucydides output and data files - by default, $USER_HOME/.thucydides
	* *thucydides.outputDirectory*: Where should reports be generated.

	* *thucydides.only.save.failing.screenshots* : Should Thucydides only store screenshots for failing steps? This can save disk space and speed up the tests a little. It is very useful for data-driven testing. This property is now deprecated. Use +thucydides.take.screenshots+ instead.

  * *thucydides.verbose.screenshots* : Should Thucydides take screenshots for every clicked button and every selected link? By default, a screenshot will be stored at the start and end of each step. If this option is set to true, Thucydides will record screenshots for any action performed on a WebElementFacade, i.e. any time you use an expression like element(...).click(), findBy(...).click() and so on. This will be overridden if the ONLY_SAVE_FAILING_SCREENSHOTS option is set to true.
  @Deprecated This property is still supported, but thucydides.take.screenshots provides more fine-grained control.

  * *thucydides.take.screenshots* : Set this property to have more finer control on how screenshots are taken. This property can take the folowing values:
    ** *FOR_EACH_ACTION* : Similar to +thucydides.verbose.screenshots+
    ** *BEFORE_AND_AFTER_EACH_STEP*,
    ** *AFTER_EACH_STEP*, and
    ** *FOR_FAILURES* : Similar to +thucydides.only.save.failing.screenshots+

	
  * *thucydides.verbose.steps* : Set this property to provide more detailed logging of WebElementFacade steps when tests are run.

  * *thucydides.report.show.manual.tests*: Show statistics for manual tests in the test reports.

  * *thucydides.report.show.releases*: Report on releases.

  * *thucydides.restart.browser.frequency*: During data-driven tests, some browsers (Firefox in particular) may slow down over time due to memory leaks. To get around this, you can get Thucydides to start a new browser session at regular intervals when it executes data-driven tests.

	* *thucycides.step.delay*: Pause (in ms) between each test step.

	* *untrusted.certificates*: Useful if you are running Firefox tests against an HTTPS test server without a valid certificate. This will make Thucydides use a profile with the AssumeUntrustedCertificateIssuer property set.

	* *thucydides.timeout*: How long should the driver wait for elements not immediately visible.

	* *thucydides.browser.width* and *thucydides.browser.height*: Resize the browser to the specified dimensions, in order to take larger screenshots. This should work with Internet Explorer and Firefox, but not with Chrome.

	* *thucydides.resized.image.width* : Value in pixels. If set, screenshots are resized to this size. Useful to save space.

  * *thucydides.keep.unscaled.screenshots* : Set to +true+ if you wish to save the original unscaled screenshots. This is set to +false+ by default.

  * *thucydides.store.html.source* : Set this property to +true+ to save the HTML source code of the screenshot web pages. This is set to +false+ by default. 

	* *thucydides.issue.tracker.url*: The URL used to generate links to the issue tracking system.
	
	* *thucydides.activate.firebugs* : * Activate the Firebugs and FireFinder plugins for Firefox when running the WebDriver tests. This is useful for debugging, but is not recommended when running the tests on a build server. 

  * *thucydides.batch.strategy* : Defines batch strategy. Allowed values - DIVIDE_EQUALLY (default) and DIVIDE_BY_TEST_COUNT. DIVIDE_EQUALLY will simply divide the tests equally across all batches. This could be inefficient if the number of tests vary a lot between test classes. A DIVIDE_BY_TEST_COUNT strategy could be more useful in such cases as this will create batches based on number of tests.

  * *thucydides.batch.count*: If batch testing is being used, this is the size of the batches being executed.

  * *thucydides.batch.number* :If batch testing is being used, this is the number of the batch being run on this machine. 

  * *thcydides.reports.show.step.details* : Displays detailed step results in the test result tables. This property is set to false by default.

  * *thucydides.use.unique.browser* : Set this to run all web tests in a single browser. 

  * *thucydides.locator.factory* :   Set this property to override the default locator factory with another locator factory (for ex., AjaxElementLocatorFactory or DefaultElementLocatorFactory). By default, Thucydides uses a custom locator factory called DisplayedElementLocatorFactory.

  * *thucydides.driver.capabilities* : A set of user-defined capabilities to be used to configure the WebDriver driver. Capabilities should be passed in as a semi-colon-separated list of key:value pairs, e.g. "build:build-1234; max-duration:300; single-window:true; tags:[tag1,tag2,tag3]"

  * *thucydides.native.events* : Activate and deactivate native events for Firefox by setting this property to +true+ or +false+.

  * *security.enable_java* : Set this to true to enable Java support in Firefox. By default, this is set to false as it slows down the web driver.

  * *thucydides.test.requirements.basedir* : The base folder of the sub-module where the jBehave stories are kept. It is assumed that this directory contains sub folders src/test/resources. If this property is set, the requirements are read from src/test/resources under this folder instead of the classpath or working directory. This property is used to support situations where your working directory is different from the requirements base dir (for example when building a multi-module project from parent pom with requirements stored inside a sub-module)

  * *thucydides.proxy.http*: HTTP Proxy URL configuration for Firefox and PhantomJS

  * *thucydides.proxy.http_port*: HTTP Proxy port configuration for Firefox and PhantomJS
  * *thucydides.proxy.type*: HTTP Proxy type configuration for Firefox and PhantomJS

  * *thucydides.proxy.user*: HTTP Proxy username configuration for Firefox and PhantomJS

  * *thucydides.proxy.password*: HTTP Proxy password configuration for Firefox and PhantomJS

  * *chrome.switches*: Arguments to be passed to the Chrome driver, separated by commas.
                                 
An example of using these parameters is shown here:

------------------
$ mvn test -Dwebdriver.driver=iexplorer -Dwebdriver.base.url=http://myapp.staging.acme.com
------------------

This will run the tests against the staging server using Internet Explorer.

	* *webdriver.firefox.profile*: The path to the directory of the profile to use when starting firefox. This defaults to webdriver creating an anonymous profile. This is useful if you want to run the web tests using your own Firefox profile. If you are not sure about how to find the path to your profile, look here: http://support.mozilla.com/en-US/kb/Profiles. For example, to run the default profile on a Mac OS X system, you would do something like this:

------------------
$ mvn test -Dwebdriver.firefox.profile=/Users/johnsmart/Library/Application\ Support/Firefox/Profiles/2owb5g1d.default
------------------

On Windows, it would be something like:

------------------
C:\Projects\myproject>mvn test -Dwebdriver.firefox.profile=C:\Users\John Smart\AppData\Roaming\Mozilla\Firefox\Profiles\mvxjy48u.default
------------------

  * *firefox.preferences*: A semicolon separated list of Firefox configuration settings. For ex.,

------------------
-Dfirefox.preferences="browser.download.folderList=2;browser.download.manager.showWhenStarting=false;browser.download.dir=c:\downloads"
------------------

Integer and boolean values will be converted to the corresponding types in the Firefox preferences; all other values will be treated as Strings. You can set a boolean value to true by simply specifying the property name, e.g. +-Dfirefox.preferences=app.update.silent+.

A complete reference to Firefox's configuration settings is given http://kb.mozillazine.org/Firefox_:_FAQs_:_About:config_Entries[here].
	
  * *thucydides.history*: The directory in which build history summary data is stored for each project. Each project has it's own sub-folder within this directory. Defaults to ~./thucydides.
 
If you want to set default values for some of these properties for your own development environment (e.g. to always activate the Firebugs plugin on your development machine), create a file called +thucydides.properties+ in your home directory (or any property file as defined by setting the system property +properties+), and set any default values here. These values will still be overridden by any values defined in the environment variables. An example is shown here:

---------------
thucydides.activate.firebugs = true     
thucydides.browser.width = 1200  
---------------

=== Providing your own Firefox profile

If you need to configure your own customized Firefox profile, you can do this by using the Thucydidies.useFirefoxProfile() method before you start your tests. For example:

---------------
@Before
public void setupProfile() {
    FirefoxProfile myProfile = new FirefoxProfile();
    myProfile.setPreference("network.proxy.socks_port",9999);
    myProfile.setAlwaysLoadNoFocusLib(true);
    myProfile.setEnableNativeEvents(true);
    Thucydides.useFirefoxProfile(myProfile);
}    

@Test
public void aTestUsingMyCustomProfile() {...}          
----------------
  * *tags*: Comma separated list of tags. If provided, only jUnit classes and/or methods with tags in this list will be executed. For example,

---------------
mvn verify -Dtags="iteration:I1"

mvn verify -Dtags="color:red,flavor:strawberry"
---------------  

  * *narrative.format*: Set this property to 'asciidoc' to activate using http://www.methods.co.nz/asciidoc/[Asciidoc] format in narrative text. 

== Integrating with issue tracking systems 
 
=== Basic issue tracking integration

Thucydides can be configured to integrate with issue tracking systems such as JIRA and Trac. You specify this using the +thucydides.issue.tracker.url+ system property. This property is the URL required to open a given issue, where the number of the issue is replaced by '{0}', e.g.

------------------
http://my.jira.server/browse/MYPROJECT-{0}
------------------

To do this in Maven, you need to pass this system property to JUnit using the maven-surefire-plugin as shown here:


------------------
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-surefire-plugin</artifactId>
    <version>2.7.1</version>
    <configuration>
        <systemPropertyVariables>
            <thucydides.issue.tracker.url>http://my.jira.server/browse/MYPROJECT-{0}</thucydides.issue.tracker.url>
        </systemPropertyVariables>
    </configuration>
</plugin>  
------------------
                          
Thucydides also provides special support for the Atlassian JIRA issue tracking tool. If you provide the +jira.url+ system property instead of the +thucydides.issue.tracker.url+, you only need to provide the base URL for your JIRA instance, rather than the full path:


------------------
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-surefire-plugin</artifactId>
    <version>2.7.1</version>
    <configuration>
        <systemPropertyVariables>
            <jira.url>http://my.jira.server</jira.url>
        </systemPropertyVariables>
    </configuration>
</plugin> 
------------------   

You need to provide the issue number. You can place this in the test title, prefixed by the # character. For easyb tests, this just means mentioning the issue number (always starting with a # character) somewhere in the scenario name. For JUnit tests, you use the @Title annotation as shown here:


------------------   
@RunWith(ThucydidesRunner.class)
public class FixingAnIssueScenario {

    @Managed
    public WebDriver webdriver;

    @ManagedPages(defaultUrl = "http://www.mysite.com")
    public Pages pages;

    @Steps
    public SampleScenarioSteps steps;

    @Title("Shopping cart should let users add multiple articles - fixes issues #123")
    @Test
    public void shopping_cart_should_let_users_add_multiple_articles() {
        steps.add_item_to_cart("nuts");
        steps.add_item_to_cart("bolts");
        steps.cart_should_contain("nuts","bolts");
    }    
}        
------------------   

Another way to specify issues in JUnit is to use the @Issue or @Issues annotations. You can use the @Issue annotation to associate an individual test with a specific issue


------------------   
@Issue("#123")
@Test
public void shopping_cart_should_let_users_add_multiple_articles() {
    steps.add_item_to_cart("nuts");
    steps.add_item_to_cart("bolts");
    steps.cart_should_contain("nuts","bolts");
}    
------------------   

You can also place the @Issue annotation at the class level, in which case the issue will be associated with every test in the class:


------------------   
@RunWith(ThucydidesRunner.class)
@Issue("#123") 
public class FixingAnIssueScenario {

	@Managed
	public WebDriver webdriver;

	@ManagedPages(defaultUrl = "http://www.mysite.com")
	public Pages pages;

	@Steps
	public SampleScenarioSteps steps;

	@Test
	public void shopping_cart_should_let_users_add_multiple_articles() {
	    steps.add_item_to_cart("nuts");
	    steps.add_item_to_cart("bolts");
	    steps.cart_should_contain("nuts","bolts");
	}

	@Test
	public void some_other_test() {
	    ...
	}    
}
------------------   

If a test needs to be associated with several issues, you can use the @Issues annotation instead:


------------------   
@Issues({"#123", "#456"}) 
@Test public void shopping_cart_should_let_users_add_multiple_articles() { 
    steps.add_item_to_cart("nuts"); steps.add_item_to_cart("bolts"); 
	steps.cart_should_contain("nuts","bolts"); 
}
------------------   

When you do this, issues will appear in the Thucydides reports with a hyperlink to the corresponding issue in your issue tracking system. 

## Overriding the default reports directory

By default, Thucydides generates it's reports in the `target/site/thucydides` directory. There are a couple of ways to override this, if need be. First of all, if you are overriding the default Maven output directory, you can override the `<directory>` element in the `<build>` section of your `pom.xml` file. However, since the Maven Surefire plugin runs the tests in a forked JVM by default, you will also need to pass in the `project.build.directory` property to the unit tests by using the `<systemPropertyVariables>` configuration element, as shown here:


------------------ 
     ...
    <build>
        <directory>${basedir}/build</directory>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>2.11</version>
                <configuration>
                    <includes>
                        <include>**/*TestScenario.java</include>
                    </includes>
                    <systemPropertyVariables>
                        <project.build.directory>${project.build.directory}</project.build.directory>
                    </systemPropertyVariables>
                </configuration>
            </plugin>
            <plugin>
                <groupId>net.thucydides.maven.plugins</groupId>
                <artifactId>maven-thucydides-plugin</artifactId>
                <version>${thucydides.version}</version>
            </plugin>
        </plugins>
    </build>
------------------ 

This will result in the Thucydides reports being generated in `build/site/thucydides` instead of `target/site/thucydides'.

If you only want to override the Thucydides output directory, you can use the `thucydides.outputDirectory` and `thucydides.sourceDirectory` properties, either in the `pom.xml` file, or from the commnd line. For example, the following properties will generate the Thucydides reports in the `build/thucydides-reports` directory:

    <properties>
        <thucydides.outputDirectory>${basedir}/build/thucydides-reports</thucydides.outputDirectory>
        <thucydides.sourceDirectory>${basedir}/build/thucydides-reports</thucydides.sourceDirectory>
    </properties>


== Using Thucydides tags

Viewing test results is certainly useful, but, from a release and deployment point of view, it is just scratching the surface. Even more interesting is the ability to view test results in terms of stories, features, behaviors, scenarios, or whatever other categorizations you find useful. 

Thucydides Tags provide a very flexible mechanism for categorizing and reporting on your test results, which serve as an alternative to the Story/Feature structure described earlier. You can decide on an appropriate set of tag types (such as "feature", "behavior", "epic", "scenario", "non-functional requirement", etc.), and then assign tags of the different types to your tests. To declare a tag type, you simply use a tag of the specified type - it will then automatically appear in the Thucydides reports.

You can assign a tag manually to a test using the `@WithTag` annotation:



------------------ 
    @WithTag(name="important functionality", type = "functionality")
    class SomeTestScenarioWithTags {
        @Test
        public void a_simple_test_case() {
        }

        @WithTag(name="simple story",type = "story")
        @Test
        public void should_do_this() {
        }

        @Test
        public void should_do_that() {
        }
    }
------------------ 

Note that tags can be assigned at the test or the class level. Tag names and types are free text -

=== Writing a Thucydides tags plugin

Thucydides tags are easy to integrate with other applications, such as issue tracking or agile project management systems. In this section, we look at how to write a plugin that will let Thucydides automatically assign tags to your tests, based on your specific requirements.

In Thucydides, tags are arbitrary tuples of String values (name and type), represented by the `TagType` class. You can create a tag using the `TagTest.withName()` method, as shown here:


------------------ 
  TestTag specialFeatureTag = TestTag.withName("special feature").andType("feature");
------------------ 

Any feature types you provide will be displayed as separate tabs at the top of the reports screen, and will provide all of the usual aggregation and filtering features that come with the standard reports.

  
To define your own tags, you need to write your own tag provider, by implementing the TagProvider interface, shown below: 


------------------ 
  public interface TagProvider {
      Set<TestTag> getTagsFor(final TestOutcome testOutcome);
  }
------------------ 

The unique method of this interface, `getTagsFor()`, takes a `TestOutcome` object, and returns the set of tags associated with this test outcome. The `TestOutcome` class provides a large number of fields describing the test and it's results. For example, to obtain the list of the issues specified for this test using the `getIssues()` method. The following code is an example of a tag provider that provides a list of tags based on the test's associated issues (specified by the `@Issue` and `@Issues` annotations).


------------------ 
  import ch.lambdaj.function.convert.Converter;
  import net.thucydides.core.model.TestOutcome;
  import net.thucydides.core.model.TestTag;
  import java.util.Set;
  import static ch.lambdaj.Lambda.convert;

  public class IssueBasedTagProvider implements TagProvider {
      
      public IssueBasedTagProvider() {
      }

      public Set<TestTag> getTagsFor(final TestOutcome testOutcome) {

          Set<String> issues = testOutcome.getIssues();
          return Sets.newHashSet(convert(issues, toTestTags()));
      }

      private Converter<String, String> toTestTags() {
          return new Converter<Object, TestTag>() {

              @Override
              public TestTag convert(String issue) {
                  String tagName = getNameForTag(issue);
                  String tagType = getTypeForTag(issue);
                  return TestTag.withName(tagName).andType(tagType);
              }
          };
      }

      String getNameForTag(String issue) {...}
      String getTypeForTag(String issue) {...}
  }
------------------ 

You also need to provide a service definition in the `/META-INF/services` folder on the classpath, so that Thucydides can register and use your plugin. A simple way to do this is to create a Maven project with a file called `net.thucydides.core.statistics.service.TagProvider` in the `src/resources/META-INF/sevices` folder. This file is a text file containing the fully-qualified name of your tag provider, e.g.


------------------ 
  com.mycompany.thucydides.MyThucydidesTagProvider
------------------ 

Now just include the generated JAR file in your dependencies, and Thucydides will use it automatically to include your custom tags in the reports.

=== Bi-directional JIRA integration
  
A common strategy for organizations using JIRA is to represent story cards, and/or the associated acceptance criteria, as JIRA issues. It is useful to know what automated tests have been executed for a given JIRA story card, and what story is being tested for a given test.

You can add both of these features to your Thucydides project by using the +thucydides-jira-plugin+. First, you need to add the +thucydides-jira-plugin+ to your Maven dependencies. The dependencies you will need (including the normal Thucydides ones) are listed here:


------------------   
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit-dep</artifactId>
        <version>4.10</version>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.hamcrest</groupId>
        <artifactId>hamcrest-all</artifactId>
        <version>1.1</version>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>net.thucydides</groupId>
        <artifactId>thucydides-junit</artifactId>
        <version>0.6.1</version>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>net.thucydides.easyb</groupId>
        <artifactId>thucydides-easyb-plugin</artifactId>
        <version>0.6.1</version>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>net.thucydides.plugins.jira</groupId>
        <artifactId>thucydides-jira-plugin</artifactId>
        <version>0.6.1</version>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.codehaus.groovy</groupId>
        <artifactId>groovy-all</artifactId>
        <version>1.8.5</version>
    </dependency>
    ...
------------------   

Note that the JIRA workflow integration needs Groovy 1.8.5 or higher to work properly.

You will also need an +slf4j+ implementation, e.g. ‘slf4j-log4j12′ (if you are using Log4j) or ‘logback-classic’ (if you are using LogBack) (see http://www.slf4j.org/codes.html#StaticLoggerBinder for more details). If you’re stuck, just add slf4j-simple:


------------------   
    <dependency>
        <groupId>org.slf4j</groupId>
        <artifactId>slf4j-simple</artifactId>
        <version>1.6.1</version>
    </dependency>
------------------   

In Thucydides, you can refer to a JIRA issue by placing a reference to the corresponding JIRA issue number either in the name of the test (using the @Title annotation, for example), or, more simply, by using the @Issue or @Issues annotation as shown here:


------------------   
    @RunWith(ThucydidesRunner.class)
    public class SearchByKeywordStoryTest {

        @Managed(uniqueSession = true)
        public WebDriver webdriver;

        @ManagedPages(defaultUrl = "http://www.wikipedia.com")
        public Pages pages;

        @Steps
        public EndUserSteps endUser;

        @Issue("#WIKI-1")
        @Test
        public void searching_by_unambiguious_keyword_should_display_the_corresponding_article() {
            endUser.is_on_the_wikipedia_home_page();
            endUser.looks_up_cats();
            endUser.should_see_article_with_title("Cat - Wikipedia, the free encyclopedia");

        }
    }
------------------   

In this example, the test will be associated with issue WIKI-1.

Alternatively, you may want to associate an issue (such as a story card) with all of the stories in a test case by placing the @Issue (or @Issues) annotation at the class level:


------------------   
        @RunWith(ThucydidesRunner.class)
        @Issue("#WIKI-1")
        public class SearchByKeywordStoryTest {

            @Managed(uniqueSession = true)
            public WebDriver webdriver;

            @ManagedPages(defaultUrl = "http://www.wikipedia.com")
            public Pages pages;

            @Steps
            public EndUserSteps endUser;

            @Test
            public void searching_by_unambiguious_keyword_should_display_the_corresponding_article() {
                endUser.is_on_the_wikipedia_home_page();
                endUser.looks_up_cats();
                endUser.should_see_article_with_title("Cat - Wikipedia, the free encyclopedia");

            }
        }
------------------   

Thucydides can use these annotations to integrate with the issues in JIRA. The most simple JIRA integration involves adding links to the corresponding JIRA issues in the Thucydides reports. To activate this, you simply need to provide the *jira.url* command line option. You do however need to pass this option to JUnit using the maven-surefire-plugin, as shown here:


------------------   
  <build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-surefire-plugin</artifactId>
            <version>2.10</version>
            <configuration>
                <argLine>-Xmx1024m</argLine>
                <systemPropertyVariables>
                    <jira.url>http://jira.acme.com</jira.url>
                </systemPropertyVariables>
            </configuration>
        </plugin>
        ...
------------------   

For tighter, round-trip integration you can also use thucydides-jira-plugin. This will not only include links to JIRA
in the Thucydides reports, but it will also update the corresponding JIRA issues with links to the corresponding
Story page in the Thucydides reports. To set this up, add the thucydides-jira-plugin dependency to your project
dependencies:


------------------   
    <dependency>
        <groupId>net.thucydides.plugins.jira</groupId>
        <artifactId>thucydides-jira-plugin</artifactId>
        <version>0.6.1</version>
        <scope>test</scope>
    </dependency>
------------------   

You also need to provide a username and password to connect to JIRA, and the URL where your Thucydides reports will be published (for example, on your CI server). You do using by passing in the *jira.username*, *jira.password*, *build.id* and *hucydides.public.url* system parameters. The *build.id* parameter identifies the current test run, and helps Thucydides know whether a given JIRA issue has already been updated by another test in the current test run. Thucydides lists all of the tests for a given JIRA card, along with their results, in the JIRA comment, and optionally updates the state of the JIRA issue accordingly (see below).


------------------   
  <build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-surefire-plugin</artifactId>
            <version>2.10</version>
            <configuration>
                <argLine>-Xmx1024m</argLine>
                <systemPropertyVariables>
                    <jira.url>http://jira.acme.com</jira.url>
                    <jira.username>${jira.demo.user}</jira.username>
                    <jira.password>${jira.demo.password}</jira.password>
                    <build.id>${env.BUILD_ID}</build.id>
                    <thucydides.public.url>http://localhost:9000</thucydides.public.url>
                </systemPropertyVariables>
            </configuration>
        </plugin>
        ...
------------------   

Thucydides also generates aggregate reports grouping results for stories and features. To include the JIRA links in these reports as well, you need to set the +jiraUrl+ configuration option in the
+maven-thucydides-plugin+, as illustrated here:


------------------   
    <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-site-plugin</artifactId>
        <version>3.0-beta-3</version>
        <configuration>
            <reportPlugins>
                <plugin>
                    <groupId>net.thucydides.maven.plugins</groupId>
                    <artifactId>maven-thucydides-plugin</artifactId>
                    <version>@project.version@</version>
                    <configuration>
                         <jiraUrl>http://jira.acme.com</jiraUrl>
                     </configuration>
                 </plugin>
            </reportPlugins>
        </configuration>
    </plugin>
------------------   

If you do not want Thucydides to update the JIRA issues for a particular run (e.g. for testing or debugging purposes), you can also set +thucydides.skip.jira.updates+ to true, e.g.

------------------   
 $ mvn verify -Dthucydides.skip.jira.updates=true
------------------   

You can also configure the plugin to update the status of JIRA issues. This is deactivated by default: to use this
option, you need to set the +thucydides.jira.workflow.active+ option to ‘true’, e.g.

------------------   
 $ mvn verify -Dthucydides.jira.workflow.active=true
------------------   

The default configuration will work with the default JIRA workflow: open or in progress issues associated with successful tests will be resolved, and closed or resolved issues associated with failing tests will be reopened. If you are using a customized workflow, or want to modify the way the transitions work, you can write your own workflow configuration. Workflow configuration uses a simple Groovy DSL. The following is an example of the configuration file used for the default workflow:

------------------   
    when 'Open', {
        'success' should: 'Resolve Issue'
    }

    when 'Reopened', {
        'success' should: 'Resolve Issue'
    }

    when 'Resolved', {
        'failure' should: 'Reopen Issue'
    }

    when 'In Progress', {
        'success' should: ['Stop Progress','Resolve Issue']
    }

    when 'Closed', {
        'failure' should: 'Reopen Issue'
    }
------------------   

You can write your own configuration file and place it on the classpath of your test project (e.g. in the src/test/resources directory). Then you can override the default configuration by using the +thucydides.jira.workflow+ property in the Maven +pom.xml+ file or directly on the command line e.g.

------------------   
 $ mvn verify -Dthucydides.jira.workflow=my-workflow.groovy
------------------   

Alternatively, you can simply create a file called +jira-workflow.groovy+ and place it somewhere on your classpath. Thucydides will then use this workflow. In both these cases, you don’t need to explicitly set the +thucydides.jira.workflow.active+ property.

You can also integrate JIRA issues into your easyb Thucydides stories. When using the Thucydides easyb integration, you associate one or more issues with the easyb story as a whole, but not with the individual scenarios. You do this using the thucydides.tests_issue notation:


------------------   
    using "thucydides"

    thucydides.uses_default_base_url "http://www.wikipedia.com"
    thucydides.uses_steps_from EndUserSteps
    thucydides.tests_story SearchByKeyword

    thucydides.tests_issue "#WIKI-2"

    scenario "Searching for cats", {
        given "the user is on the home page", {
            end_user.is_on_the_wikipedia_home_page()
        }
        when "the end user searches for 'cats'", {
            end_user.looks_up_cats()
        }
        then "they should see the corresponding article", {
           end_user.should_see_article_with_title("Cat - Wikipedia, the free encyclopedia")
        }
    }
------------------   

You can also associate several issues using +thucydides.tests_issues+:

------------------   
    thucydides.tests_issue "#WIKI-2", "#WIKI-3"
------------------   

To use easyb with Thucydides, you need to add the latest version of +thucydides-easyb-plugin+ to your dependencies if it is not already there:


------------------   
    <dependency>
        <groupId>net.thucydides.easyb</groupId>
        <artifactId>thucydides-easyb-plugin</artifactId>
        <version>0.6.1</version>
        <scope>test</scope>
    </dependency>
------------------   

As with JUnit, you will need to pass in the proper parameters to easyb for this to work. You will also need to be using the maven-easyb-plugin version 1.4 or higher, configured to pass in the JIRA parameters as shown here:


------------------   
    <plugin>
        <groupId>org.easyb</groupId>
        <artifactId>maven-easyb-plugin</artifactId>
        <version>1.4</version>
        <executions>
            <execution>
                <goals>
                    <goal>test</goal>
                </goals>
            </execution>
        </executions>
        <configuration>
            <storyType>html</storyType>
            <storyReport>target/easyb/easyb.html</storyReport>
            <easybTestDirectory>src/test/stories</easybTestDirectory>
            <parallel>true</parallel>
            <jvmArguments>
                <jira.url>http://jira.acme.com</jira.url>
                <jira.username>${jira.demo.user}</jira.username>
                <jira.password>${jira.demo.password}</jira.password>
                <thucydides.public.url>http://localhost:9000</thucydides.public.url>
            </systemPropertyVariables>
            </jvmArguments>
        </configuration>
    </plugin>
------------------   

Once this is done, Thucydides will update the relevant JIRA issues automatically whenever the tests are executed.
 
== Managing screenshots
By default, Thucydides saves a screenshot for every step executed during the tests. Thucydides can be configured to control when screenshots are stored.

=== Configuring when screenshots are taken
The property +thucydides.take.screenshots+ can be set to configure how often the sreenshots are taken. This property can take the folowing values:

* +FOR_EACH_ACTION+ : Saves a screenshot at every web element action (like click(), typeAndEnter(), type(), typeAndTab() etc.). 

* +BEFORE_AND_AFTER_EACH_STEP+ : Saves a screeshot before and asfter every step.

* +AFTER_EACH_STEP+ : Saves a screenshot after every step

* +FOR_FAILURES+ : Saves screenshots only for failing steps. This can save disk space and speed up the tests a little. It is very useful for data-driven testing. 

=== Using annotations to control screenshots
An even more granular level of control is possible using annotations. You can annotate any test or step method (or any method used by a step or test) with the +@Screenshots+ annotation to override the number of screenshots taken within this step (or sub-step). Some sample uses are shown here:

------------------
@Step
@Screenshots(onlyOnFailures=true)
public void screenshots_will_only_be_taken_for_failures_from_here_on() {…}

@Test
@Screenshots(forEachStep=true)
public void should_take_screenshots_for_each_step_in_this_test() {…}

@Test
@Screenshots(forEachAction=true)
public void should_take_screenshots_for_each_action_in_this_test() {…}
------------------


=== Taking screenshots at any arbitrary point during a step
It is possible to have even finer control on capturing screenshots in the tests. Using the +takeScreenshot+ method, you can  instruct Thucydides to take a screenshot at any arbitrary point in the step irrespective of the screenshot level set using configuration or annotations.

Simply call +Thucydides.takeScreenshot()+ in the step methods whenever you want a screenshot to be captured.


=== Increasing the size of screenshots
Sometimes the default window size is too small to display all of the application screen in the screenshots. You can increase the size of the window Thucydides opens by providing the +thucydides.browser.width+ and +thucydides.browser.height+ system properties. For example, to use a browser window with dimensions of 1200x1024, you could do the following:

------------------   
$ mvn clean verify -Dthucydides.browser.width=1200 -Dthucydides.browser.height=1024
------------------   

Typically, the width parameter is the only one you will need to specify, as the height will be determined by the contents of the browser page.

If you are running Thucydides with JUnit, you can also specify this parameter (and any of the others, for that matter) directly in your pom.xml file, in the maven-surefire-plugin configuration, e.g:


------------------   
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-surefire-plugin</artifactId>
            <version>2.7.1</version>
            <configuration>
                <argLine>-Xmx1024m</argLine>
                <systemPropertyVariables>
                    <thucydides.browser.width>1200</thucydides.browser.width>
                </systemPropertyVariables>
            </configuration>
        </plugin>
        ...
------------------   

When the browser width is larger than 1000px, the slideshow view in the reports will expand to show the full screenshots.

Note there are some caveats with this feature. In particular, it will not work at all with Chrome, as Chrome, by design, does not support window resizing. In addition, since WebDriver uses a real browser, so the maximum size will be limited by the physical size of the browser. This limitation applies to the browser width, as the full vertical length of the screen will still be recorded in the screenshot even if it scrolls beyond a single page.

==== Screenshots and OutOfMemoryError issues
Selenium needs memory to take screenshots, particularly if the screens are large. If Selenium runs out of memory when taking screenshots, it will log an error in the test output. In this case, configure the maven-surefire-plugin to use more memory, as illustrated here:


------------------   
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-surefire-plugin</artifactId>
    <version>2.7.1</version>
    <configuration>
        <argLine>-Xmx1024m</argLine>
    </configuration>
</plugin>
------------------   

=== Saving raw screenshots
Thucydides saves only rescaled screenshots by default. This is done to help reduce the disk space taken by reports. If you require to save the original unscaled screenshots, this default can be easily overridden by setting the property, +thucydides.keep.unscaled.screenshots+ to +true+.

=== Saving HTML source files for screenshots
It is possible to save html source files for the screenshots by setting the property, +thucydides.store.html.source+ to +true+. Html source files are not saved by default to conserve disk space.

=== Blurring sensitive screenshots
For security/privacy reasons, it may be required to blur sensitive screenshots in Thucydides reports. This can be done by annotating the test methods or steps with the annotation +@BlurScreenshots+. When defined on a test, all screenshots for that test will be blurred. When defined on a step, only the screenshot for that step will be blurred. @BlurredScreenshot takes a string parameter with values +LIGHT, MEDIUM+ or +HEAVY+ to indicate the amount of blurring. For example,

------------------
@Test
@BlurScreenshots("HEAVY")
public void looking_up_the_definition_of_pineapple_should_display_the_corresponding_article() {
    endUser.is_the_home_page();
    endUser.looks_for("pineapple");
    endUser.should_see_definition_containing_words("A thorny fruit");
}
------------------

A screen at various blur levels is shown below.

[[fig-screen_blur_light]]
.A lightly blurred screenshot
image::figs/blur/light.png[scaledwidth="80%", width=475]

[[fig-screen_blur_medium]]
.A medium blurred screenshot
image::figs/blur/medium.png[scaledwidth="80%", width=475]

[[fig-screen_blur_heavy]]
.A heavily blurred screenshot
image::figs/blur/heavy.png[scaledwidth="80%", width=475]

               
== Managing state between steps                  

Sometimes it is useful to be able to pass information between steps. For example, you might need to check that client detailed entered on a registration appears correctly on a confirmation page later on. 

You can do this by passing values from one step to another, however this tends to clutter up the steps. Another approach is to use the Thucydides test session, which is essentially a hash map where you can store variables for the duration of a single test. You can obtain this session map using the +Thucydides.getCurrentSession()+ static method.

As illustrated here, you can p


------------------
@Step
public void notes_publication_name_and_date() {
    PublicationDatesPage page = pages().get(PublicationDatesPage.class);
    String publicationName = page.getPublicationName();
    DateTime publicationDate = page.getPublicationDate();

    Thucydides.getCurrentSession().put("publicationName", publicationName);
    Thucydides.getCurrentSession().put("publicationDate", publicationDate);
}
------------------

Then, in a step invoked later on in the test, you can check the values stored in the session:


-------------------
public void checks_publication_details_on_confirmation_page() {

    ConfirmationPage page = pages().get(ConfirmationPage.class);

    String selectedPublicationName = (String) Thucydides.getCurrentSession().get("publicationName");
    DateTime selectedPublicationDate = (DateTime) Thucydides.getCurrentSession().get("publicationDate");

    assertThat(page.getPublicationDate(), is(selectedPublicationName));
    assertThat(page.getPublicationName(), is(selectedPublicationDate));

}
-------------------

If no variable is found with the requested name, the test will fail. The test session is cleared at the start of each test. 

== Data-Driven Testing

=== Data-Driven Tests in JUnit

In JUnit 4, you can use the Parameterized test runner to perform data-driven tests. In Thucydides, you use the +ThucydidesParameterizedRunner+. This runner is very similar to the JUnit Parameterized test runner, except that you use the TestData annotation to provide test data, and you can use all of the other Thucydides annotations (+@Managed+, +@ManagedPages+, +@Steps+ and so on). This test runner will also generate proper Thucydides HTML and XML reports for the executed tests.

An example of a data-driven Thucydides test is shown below. In this test, we are checking that valid ages and favorite colors are accepted by the sign-on page of an (imaginary) application. To test this, we use several combinations of ages and favorite colors, specified by the testData() method. These values are represented as instance variables in the test class, and instantiated via the constructor.


------------------   
@RunWith(ThucydidesParameterizedRunner.class)
public class WhenEnteringPersonalDetails {

    @TestData
    public static Collection<Object[]> testData() {
        return Arrays.asList(new Object[][]{
                {25, "Red"},
                {40, "Blue"},
                {36, "Green"},
        });
    }

    @Managed
    public WebDriver webdriver;

    @ManagedPages(defaultUrl = "http://www.myapp.com")
    public Pages pages;

    @Steps
    public SignupSteps signup;

    private Integer age;
    private String favoriteColor;

    public WhenEnteringPersonalDetails(Integer age, String favoriteColor) {
        this.age = age;
        this.favoriteColor = favoriteColor;
    }

    @Test 
    public void valid_personal_details_should_be_accepted() {
        signup.navigateToPersonalDetailsPage();
        signup.enterPersonalDetails(age, favoriteColor);
    }  
}
--------------

=== Reporting on data-driven web tests

When you generate reporting on data-driven web tests, the reports display full test outcomes and screenshots for each set of data. An overall story report is displayed for the data-driven test, which a test case for each row of test data. The test data used for each test is displayed in the report.
    
=== Running data-driven tests in parallel   

Data-driven web tests can be long, especially if you need to navigate to a particular page before testing a different field value each time. In most cases, however, this is necessary, as it is unsafe to make assumptions about the state of the web page after a previous data-driven test. One effective way to speed them up, however, is to run them in parallel. You can configure +ThucydidesParameterizedRunner+ tests to run in parallel by using the Concurrent annotation.


------------------   
@RunWith(ThucydidesParameterizedRunner.class)
@Concurrent
public class WhenEnteringPersonalDetails {...
-----------------

By default, this will run your tests concurrently, by default using two threads per CPU core. If you want to fine-tune the number of threads to be used, you can specify the 'threads' annotation property.


------------------   
@RunWith(ThucydidesParameterizedRunner.class)
@Concurrent(threads="4")
public class WhenEnteringPersonalDetails {...
--------------

You can also express this as a value relative to the number of available processors. For example, to run 4 threads per CPU, you could specify the following:


------------------   
@RunWith(ThucydidesParameterizedRunner.class)
@Concurrent(threads="4x")
public class WhenEnteringPersonalDetails {...
---------

=== Data-driven testing using CSV files

Thucydides lets you perform data-driven testing using test data in a CSV file. You store your test data in a CSV file (by default with columns separated by commas), with the first column acting as a header:

---------------
	NAME,AGE,PLACE OF BIRTH
	Jack Smith, 30, Smithville
	Joe Brown, 40, Brownville
	Mary Williams, 20, Williamsville
---------------

Next, create a test class containing properties that match the columns in the test data. Each property should be a property by the JavaBeans definition, with a matching getter and setter. The test class will typically contain one or more tests that use these properties as parameters to the test step or Page Object methods.

The class will also contain the *@UseTestDataFrom* annotation to indicate where to find the CSV file (this can either be a file on the classpath or a relative or absolute file path - putting the data set on the class path (e.g. in +src/test/resources+) makes the tests more portable). 

You also use the *@RunWith* annotation as well as the other usual Thucydides annotations (+@Managed+, +@ManagedPages+ and +@Steps+). 

An example of such a class is shown here:


------------------   
	@RunWith(ThucydidesParameterizedRunner.class)
	@UseTestDataFrom("test-data/simple-data.csv")
	public class SampleCSVDataDrivenScenario {

	    private String name;
	    private String age;
	    private String placeOfBirth;

	    public SampleCSVDataDrivenScenario() {
	    }

	    @Qualifier
	    public String getQualifier() {
	        return name;
	    }

	    @Managed
	    public WebDriver webdriver;

	    @ManagedPages(defaultUrl = "http://www.google.com")
	    public Pages pages;

	    @Steps
	    public SampleScenarioSteps steps;

	    @Test
	    public void data_driven_test() {
	        System.out.println(getName() + "/" + getAge() + "/" + getCity());
	    }

	    public String getName() {
	        return name;
	    }

	    public void setName(String name) {
	        this.name = name;
	    }

	    public String getAge() {
	        return age;
	    }

	    public void setAge(String age) {
	        this.age = age;
	    }

	    public String getPlaceOfBirth() {
	        return placeOfBirth;
	    }

	    public void setPlaceOfBirth(String placeOfBirth) {
	        this.placeOfBirth = placeOfBirth;
	    }
	}
---------

You can also specify multiple file paths separated by path separators – colon, semi-colon or comma. For example:

---------
 
	@UseTestDataFrom("test-data/simple-data.csv,test-data-subfolder/simple-data.csv")

---------


You can also configure an arbitrary directory using system property +thucydides.data.dir+ and then refer to it as +$DATADIR+ variable in the annotation.

---------
 
	@UseTestDataFrom("$DATADIR/simple-data.csv")

---------

Each row of test data needs to be distinguished in the generated reports. By default, Thucydides will call the +toString()+ method. If you provide a public method returning a String that is annotated by the +@Qualifier+ annotation, then this method will be used to distinguish data sets. It should return a value that is unique to each data set.

The test runner will create a new instance of this class for each row of data in the CSV file, assigning the properties with corresponding values in the test data. SoWhen we run this test, we will get an output like this:

---------------
	Jack Smith/30/Smithville
	Joe Brown/40/Brownville
	Mary Williams/20/Williamsville
---------------

There are a few points to note. The columns in the CSV files are converted to camel-case property names (so "NAME" becomes +name+ and "PLACE OF BIRTH" becomes +placeOfBirth+). Since we are testing web applications, all of the fields should be strings.

If some of the field values contain commas, you will need to use a different separator. You can use the *separator* attribute of the *@UseTestDataFrom* annotation to specify an alternative separator. For example, the following data uses a semi-colon separator:

-----------
    NAME;AGE;ADDRESS
    Joe Smith; 30; 10 Main Street, Smithville
    Jack Black; 40; 1 Main Street, Smithville
    Mary Williams, 20, 2 Main Street, Williamsville
------------

To run our tests against this data, we would use a test class like the following:


------------------   
	@RunWith(ThucydidesParameterizedRunner.class)
	@UseTestDataFrom(value="test-data/simple-semicolon-data.csv", separator=';')
	public class SampleCSVDataDrivenScenario {

	    private String name;
	    private String age;
	    private String address;

	    public SampleCSVDataDrivenScenario() {
	    }

	    @Qualifier
	    public String getQualifier() {
	        return name;
	    }

	    @Managed
	    public WebDriver webdriver;

	    @ManagedPages(defaultUrl = "http://www.google.com")
	    public Pages pages;

	    @Steps
	    public SampleScenarioSteps steps;

	    @Test
	    public void data_driven_test() {
	        System.out.println(getName() + "/" + getAge() + "/" + getAddress());
	    }

	    public String getName() {
	        return name;
	    }

	    public void setName(String name) {
	        this.name = name;
	    }

	    public String getAge() {
	        return age;
	    }

	    public void setAge(String age) {
	        this.age = age;
	    }

	    public String getAddress() {
	        return address;
	    }

	    public void setAddress(String address) {
	        this.address = address;
	    }
	}
------------

This will generate an output like this:

-------------
	Joe Smith/30/10 Main Street, Smithville
	Jack Black/40/1 Main Street, Smithville
	Mary Williams/20/2 Main Street, Williamsville
-------------

Excel support will be added in a future version. However if you store your test data in CSV form, it becomes easier to keep track of changes to test data in your version control system.

=== Using data-driven testing for individual steps

Sometimes you want to use data-driven testing at the step level, rather than at the test level. For example, you might want to navigate to a particular screen in the application, and then try many combinations of data, or loop over a sequence of steps with data from a CSV file. This avoids having to reopen the browser for each row of data.

You can do this by adding property values to your Step files. Consider the following steps file:


------------------   
	public class SampleDataDrivenSteps extends ScenarioSteps {

	    public SampleDataDrivenSteps(Pages pages) {
	        super(pages);
	    }

	    private String name;
	    private String age;
	    private String address;

	    public void setName(String name) {
	        this.name = name;
	    }

	    public void setAge(String age) {
	        this.age = age;
	    }

	    public void setAddress(String address) {
	        this.address = address;
	    }

	    @StepGroup
	    public void enter_new_user_details() {
	        enter_name_and_age(name, age);
	        enter_address(address);
	    }

	    @Step
	    public void enter_address(String address) {
	        ...
	    }

	    @Step
	    public void enter_name_and_age(String name, String age) {
	        ...
	    }
	
		@Step
		public void navigate_to_user_accounts_page() {
			...
		}
	}
--------------

The +enter_personal_details+ step group uses the step fields to run the +enter_name_and_age+ and +enter_address steps+. We want to fetch this data from a CSV file, and loop through the *enter_personal_details* step for each row of data.

We do this using the +withTestDataFrom()+ method of the *StepData* class:


------------------   
	import net.thucydides.core.annotations.ManagedPages;
	import net.thucydides.core.annotations.Steps;
	import net.thucydides.core.pages.Pages;
	import net.thucydides.junit.annotations.Managed;
	import net.thucydides.junit.runners.ThucydidesRunner;
	import org.junit.Test;
	import org.junit.runner.RunWith;
	import org.openqa.selenium.WebDriver;

	import static net.thucydides.core.steps.StepData.withTestDataFrom;

	@RunWith(ThucydidesRunner.class)
	public class SamplePassingScenarioWithTestSpecificData {

	    @Managed
	    public WebDriver webdriver;

	    @ManagedPages(defaultUrl = "http://www.google.com")
	    public Pages pages;
    
	    @Steps
	    public SampleDataDrivenSteps steps;


	    @Test
	    public void happy_day_scenario() throws Throwable {
			steps.navigate_to_user_accounts_page();
	        withTestDataFrom("test-data/simple-data.csv").run(steps).enter_new_user_details();
	    }
	}
--------------
	
This will call the +data_driven_test_step()+ multiple times, each time injecting data from the +test-data/simple-data.csv+ file into the step.

You also can use as many data files as you want, even in the same test. You can also use the same data file for more than one test step. Remember only the properties that match columns in the CSV file will be instantiated - the others will be ignored:


------------------   
	@RunWith(ThucydidesRunner.class)
	public class SamplePassingScenarioWithTestSpecificData {

	    @Managed
	    public WebDriver webdriver;

	    @ManagedPages(defaultUrl = "http://www.google.com")
	    public Pages pages;

	    @Steps
	    public SampleDataDrivenSteps steps;

	    @Steps
	    public DifferentDataDrivenSteps different_steps;


	    @Test
	    public void happy_day_scenario() throws Throwable {
			steps.navigate_to_user_accounts_page();

	        withTestDataFrom("test-data/simple-data.csv").run(steps).enter_new_user_details();

	        withTestDataFrom("test-data/some_other-data.csv").run(different_steps).enter_other_details();
	    }
	}
-------------------

By the way we need to use +ThucydidesRunner+ for the test cases instead of +ThucydidesParameterizedRunner+.

Note that, as a shortcut, you can dispense with the setter methods and just declare the relevant fields public. So the Steps class shown above could be rewritten like this:


------------------   
	public class SampleDataDrivenSteps extends ScenarioSteps {

	    public SampleDataDrivenSteps(Pages pages) {
	        super(pages);
	    }

	    public String name;
	    public String age;
	    public String address;

	    @StepGroup
	    public void enter_new_user_details() {
	        enter_name_and_age(name, age);
	        enter_address(address);
	    }

	    @Step
	    public void enter_address(String address) {
	        ...
	    }

	    @Step
	    public void enter_name_and_age(String name, String age) {
	        ...
	    }

		@Step
		public void navigate_to_user_accounts_page() {
			...
		}
	}
-------------------
   
== Running Thucydides tests in parallel batches

Web tests make good candidates for concurrent testing, in theory at least, but the implementation can be tricky. For example, although it is easy enough to configure both JUnit and easyb to run tests in parallel, running several webdriver instances of Firefox in parallel on the same display, for example, tends to become unreliable.

The natural solution in this case is to split the web tests into smaller batches, and to run each batch on a different machine and/or on a different virtual display. When each batch has finished, the results can be retrieved and aggregated into the final test reports.

However splitting tests into batches by hand tends to be tedious and unreliable – it is easy to forget to add a new test to a batch, for example, or have unevenly-distributed batches.

The latest version of Thucydides lets you do this automatically, by splitting your test cases evenly into batches of a given size. In practice, you run a build job for each batch. You need to specify two parameters when you run each build: the total number of batches being run (+thucydides.batch.count+), and the number of the batch being run in this build (+thucydides.batch.number+).

For example, the following will divide the test cases into 3 batches (+thucydides.batch.count+), and only run the first test in each batch (+thucydides.batch.number+):
                                     
------------------
mvn verify -Dthucydides.batch.count=3 -Dthucydides.batch.number=1
------------------

This will only work with the JUnit integration. However this feature is also supported in easyb (as of easyb version 1.5), though using different parameters. When using the Thucydides easyb integration, you also need to provide the equivalent options for easyb:

------------------
mvn verify -Deasyb.batch.count=3 -Deasyb.batch.number=1
------------------

If you have both easyb and JUnit Thucydides tests, you will need to specify both options.

=== Test count based batch strategy
By default, test cases are divided equally among batches. This could be inefficient if some test cases have more tests than others. In such situations, a different batch strategy, +DIVIDE_BY_TEST_COUNT+ can be defined using the system property +thucydides.batch.strategy+. This strategy will evenly distribute test cases across batches based on number of test methods in each test case.

------------------
mvn verify -Dthucydides,batch.strategy=DIVIDE_BY_TEST_COUNT -Dthucydides.batch.count=3 -Dthucydides.batch.number=1
------------------

== Experimental features
=== Integration with FluentLineum
You can use https://github.com/FluentLenium/FluentLenium[FluentLenium‘s] fluent API with Thucydides. The best way to use FluentLenium within Thucydides is to use ThucydidesFluentAdapter which is available in PageObject. Here’s an example of the same PageObject written in the traditional style and with FluentLenium.

------------------
import ch.lambdaj.function.convert.Converter;
import net.thucydides.core.annotations.DefaultUrl;
import org.openqa.selenium.By;
import org.openqa.selenium.Keys;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.support.FindBy;

import net.thucydides.core.pages.PageObject;

import java.util.List;

import static ch.lambdaj.Lambda.convert;

@DefaultUrl("http://en.wiktionary.org/wiki/Wiktionary:Main_Page")
public class DictionaryPage extends PageObject {

    @FindBy(name="search")
    private WebElement searchTerms;

    @FindBy(name="go")
    private WebElement lookupButton;

    public DictionaryPage(WebDriver driver) {
        super(driver);
    }

    public void enter_keywords(String keyword) {
        element(searchTerms).type(keyword);
    }

    public void lookup_terms() {
        element(lookupButton).click();
    }

    public List getDefinitions() {
        WebElement definitionList = getDriver().findElement(By.tagName("ol"));
        List results = definitionList.findElements(By.tagName("li"));
        return convert(results, toStrings());
    }

    private Converter<WebElement, String> toStrings() {
        return new Converter<WebElement, String>() {
            public String convert(WebElement from) {
                return from.getText();
            }
        };
    }
}
------------------

and with FluentLineum

------------------
import ch.lambdaj.function.convert.Converter;
import net.thucydides.core.annotations.DefaultUrl;
import net.thucydides.core.pages.PageObject;
import org.fluentlenium.core.domain.FluentList;
import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.support.FindBy;

import java.util.List;

import static ch.lambdaj.Lambda.convert;
import static org.fluentlenium.core.filter.FilterConstructor.withName;

@DefaultUrl("http://en.wiktionary.org/wiki/Wiktionary:Main_Page")
public class FluentDictionaryPage extends PageObject {

    public FluentDictionaryPage(WebDriver driver) {
        super(driver);
    }

    public void enter_keywords(String keyword) {
        fluent().fill("input", withName("search")).with(keyword);
    }

    public void lookup_terms() {
        fluent().click("input", withName("go"));
    }

    public List getDefinitions() {
        FluentList results = fluent().findFirst("ol").find("li");
        return results.getTexts();
    }
}
------------------

=== Shortcut for the element() method
Another new experimental feature introduces the ability to replace the commonly-used element() method with ‘$’, as illustrated in the following examples:

------------------
    ...
    @FindBy(name="search")
    private WebElement searchTerms;

    @FindBy(name="go")
    private WebElement lookupButton;

    public DictionaryPage(WebDriver driver) {
        super(driver);
    }

    public void enter_keywords(String keyword) {
        $(searchTerms).type(keyword);
    }

    public void lookup_terms() {
        $(lookupButton).click();
    }

    public void click_on_article(int articleNumber) {
        $("//section[@id='searchResults']/article[" + articleNumber + "]//a").click();
    }

    public String getHeading() {
        return $("section>h1").getText()
    }
}

------------------

=== Retrying failed tests

Sometimes it is required to retry a failed test. This can be achieved by setting the system property +max.retries+ to the number of times you want failed tests to be retried. If +max.retries+ provided, all method tests will be executed until first successful run, but not more than 1 + +max.retries+ times.


=== Using Step methods to document test cases
Methods in the Step library can be used to provide additional documentation for the test scenarios in Thucydides reports. You can pass valid HTML text as parameter to @Step methods in the step library. This will show up as formatted text in the reports on the step details page. The following screenshot demonstrates this.

[[fig-html-argument-shows-up-in-test-report]]
.HTML formatted text, if passed to a step method will be displayed as shown. This can be useful for annotating or documenting the tests with helpful information.
image::figs/html-argument-shows-up-in-test-report.jpg[scaledwidth="80%", width=475]

This is achieved by creating a dummy @Step method called description that takes a String parameter. At runtime, the tests supply this method with formatted html text as parameter.

------------------
...
@Step
public void description(String html) {
    //do nothing
}

public void about(String description, String...remarks) {
    String html =
    "<h2 style=\"font-style:italic;color:black\">" + description + "</h2>" +
    "<div><p>Remarks:</p>" +
    "<ul style=\"margin-left:5%; font-weight:200; color:#434343; font-size:10px;\">";

    for (String li : remarks) html += "<li>" + li + "</li>";

    html += "<ul></div>";

    description(html);
}
...
------------------



[[further-reading]]
   
== Further Reading

.Articles
- Dr. Dobb's Journal. http://drdobbs.com/open-source/232300277/[Project of the Month: Thucydides], December. 2011.              
- JavaWorld. http://www.javaworld.com/javaworld/jw-08-2011/110823-atdd-for-web-apps.html[Acceptance test driven development for web applications], August. 2011.  

- JavaWorld. http://www.javaworld.com/javaworld/jw-10-2011/111018-thucydides-for-atdd.html[Selenium 2 and Thucydides for ATDD], August. 2011.

.Books
- Bdd in Action, http://manning.com/smart[BDD In Action - Manning - Summer, 2014      ]


